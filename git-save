#!/bin/bash
set -e && if [[ $1 = --debug ]]; then shift && set -x; fi

USAGE='git save [-u|-A] [-c COMMAND]
git save --redo-last | --redo-since=BASE
git save --root

 
Commit changes with a standard message, given by git-summary(1).
With `-u` or `-A`, first update the index using git-add(1).
 
If invoked with `-c COMMAND`, run COMMAND in a shell and commit
the resulting changes, using "$ COMMAND" as the commit message.
 
If neither `-u`, `-A` nor `-c` were given, and the index is
already clean, then invoke `git add -u` first.

The `--redo-last` option recreates the last commit from scratch,
whereas `--redo-since` is used to start an interactive rebase.
 
git-save(1) prefixes all its commit messages with `~`.
--
u                Run `git add -u` first
A                Run `git add -A` first
 
c,command=       Commit the results of `sh -c CMD`
 
R,redo-last      Redo the last commit from scratch
redo-since=      Redo all git-save commits since BASE

root             Create an empty root commit
 
debug            Run in debug mode
'
eval "$(git rev-parse --parseopt -- "$@" <<< "$USAGE" || exit $?)"

add_options=()

while test $# != 0; do
  case $1 in
    -u|-A) add_options+=($1) && shift ;;
    -c) command=$2 && shift && shift ;;
    -R) redo_last=true && shift ;;
    --root) root=true && shift ;;
    --redo-since) redo_base=$2 && shift && shift ;;
    --) shift ;;
    *) echo Unknown option: $1 >&2 && exit 1 ;;
  esac
done

if [[ $root ]]; then
  git commit --allow-empty -m\~
elif [[ $redo_last ]]; then
  if [[ $command || $add_options ]]; then
    echo $0: -R is incompatible with -u, -A and -c >&2 && exit 1
  else
    message=`git log --format=%s -n1`
    if [[ $message =~ ^~\$\ (.*) ]]; then
      command=${BASH_REMATCH[1]}
      echo "git-save:~\$ $command"
      git reset --hard HEAD^
      git save -A -c "$command"
    elif [[ $message =~ ^~(.*) ]]; then
      if git rev-parse HEAD^ >/dev/null 2>&1
      then parent=HEAD^
      else parent=`git hash-object -t tree /dev/null`; fi
      summary=`git-summary $parent HEAD`      
      if [[ $message = "~$summary" ]]; then
        echo "git-save: patch summary up-to-date"
      else
        echo "git-save: updating patch summary"
        git commit --amend -m "~$summary"
      fi
    else
      echo "git-save: skip"
    fi
  fi
elif [[ $redo_base ]]; then
  git rebase -i -x 'git save --redo-last' $redo_base --onto $redo_base
else
  function --index-clean {
    git diff-index --cached --quiet HEAD
  }

  if [[ $command ]]; then
    if test -z "`git status --short`"; then
      (cd "`git rev-parse --show-toplevel`" && sh -c "$command")
      git add ${add_options[*]--u}
    else
      echo You have uncommited changes >&2 && exit 1
    fi
  elif [[ $add_options ]]; then
    git add ${add_options[*]}
  elif --index-clean; then
    git add -u && if --index-clean; then git add -A; fi
  fi

  function --commit-message {
    if [[ $command ]]; then
      printf '$ %s' "$command"
    else
      git summary --cached
    fi
  }

  git commit -m "~`--commit-message`"
fi
