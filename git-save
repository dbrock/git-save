#!/bin/bash

set -e

MESSAGE_PREFIX=\~
USAGE='git save [-u|-A] [-c COMMAND]

 
Commit changes with a standard message, given by git-summary(1).
With `-u` or `-A`, first update the index using git-add(1).
 
If invoked with `-c COMMAND`, run COMMAND in a shell and commit
the resulting changes, using "$ COMMAND" as the commit message.
 
If neither `-u`, `-A` nor `-c` were given, and the index is
already clean, then invoke `git add -u` first.
 
git-save(1) prefixes all its commit messages with `'"$MESSAGE_PREFIX"'`.
--
u,update     Run `git add -u` first
A,all        Run `git add -A` first
 
c,command    Run `sh -c COMMAND` first
'

eval "$(git rev-parse --parseopt -- "$@" <<< "$USAGE" || exit $?)"

add_options=()

while test $# != 0; do
  case $1 in
    -u|-A) add_options+=($1) && shift ;;
    -c) command=$2 && shift 2 ;;
    --) shift ;;
    *) exit 1 ;;
  esac
done

function --index-clean { git diff-index --cached --quiet HEAD; }

if [[ $command ]]; then
  if test -z "`git status --short`"; then
    (cd "`git rev-parse --show-toplevel`" && sh -c "$command")
    git add ${add_options[*]--u}
  else
    echo You have uncommited changes >&2 && exit 1
  fi
elif [[ $add_options ]]; then
  git add ${add_options[*]}
elif --index-clean; then
  git add -u
fi

function --commit-message {
  if [[ $command ]]; then
    printf '$ %s' "$command"
  else
    git summary --cached
  fi
}

git commit -m "$MESSAGE_PREFIX`--commit-message`"
